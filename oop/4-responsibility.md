# Assignment Responsibility
올바른 객체지향 설계는 클라이언트가 보낼 메시지를 먼저 결정한 후
그 메시지를 수신할 객체를 고른다. 이후 받을 메시지가 확실해지면
그때 그 객체에 데이터를 결정한다. 이를 통해서 메시지 송신자는 수신자의 데이터를 알 수 없게되고 객체가 깔끔하게 캡슐화되는 것이다.

### 책임주도 설계
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### GRASP(General Responsibility Assignment Software Pattern)

1. Start to Domain Concept
2. Use Information Expert Pattern
**정보 전문가** 는 그 해당 정보를 알고있는 객체에게 책임을 맡긴다는 의미이다.
여기서 **정보**와 **데이터**는 다르다.   

### How to Identified Class that have to changed
1. 인스턴스 변수가 초기화되는 시점을 살펴본다.
	응집도가 높은 클래스는 인스턴스 변수가 한번에 초기화된다.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다.
	
결국 역할이라는 것이 대두된다.
이전까지 하나의 책임이 하나의 클래스를 의미했다면 
역할의 관점에서 살펴보면 책임이란 하나의 역할이 수행하는 것이며
역할은 다형성을 통해 여러개의 클래스가 수행할 수 있다 이는 캡슐화의 관점에서 책임을 할당해주는 클래스입장에서는 역할을 수행하는 클래스가 어떤것인지는 직접적으로 알지 못 한다. 그냥 그 역할을 수행해줄 수 있는 클래스면 그만이다.

### 메서드 하나에 모든 로직이 들어있을 때
- 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는데 너무 많은 시간이 걸린다.
- 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.
- 